가상 DOM(Virtual DOM)은 실제 DOM(Document Object Model)을 조작하기 전에 메모리에서 미리 변경 사항을 반영하는 가상의 DOM 트리입니다.
React는 이 가상 DOM을 활용하여 UI를 효율적으로 업데이트합니다.

<hr/>

기존의 웹 애플리케이션에서 DOM을 직접 조작하면 다음과 같은 문제가 있었습니다.

DOM 조작 비용이 크다
DOM 요소를 변경할 때마다 브라우저가 레이아웃 계산, 리렌더링, 페인트(Painting) 작업을 수행해야 합니다.
변경이 많아지면 성능이 급격히 저하됩니다.
UI 업데이트 최적화 필요
변경된 부분만 갱신하면 성능이 좋아지지만, 이를 직접 관리하기 어렵습니다.
React는 가상 DOM을 사용하여 변경 사항을 효율적으로 적용합니다.

<hr/>

React의 가상 DOM은 다음과 같은 방식으로 동작합니다.

🛠 1. 상태(State) 변경 발생
컴포넌트의 state나 props가 변경되면 새로운 가상 DOM이 생성됩니다.
🔍 2. 새로운 가상 DOM 생성
변경된 state를 반영한 새로운 Virtual DOM 트리를 만듭니다.
⚡ 3. Diffing 알고리즘 실행 (변경된 부분 찾기)
React는 기존 가상 DOM과 새로운 가상 DOM을 비교(디핑, Diffing)하여 변경된 부분을 찾습니다.
React의 핵심 알고리즘인 Reconciliation(조정) 과정이 수행됩니다.
🖌 4. 변경된 부분만 실제 DOM에 반영 (Patch)
변경된 부분만 업데이트하여 최소한의 DOM 조작을 수행합니다.
이 과정을 **DOM 업데이트 최적화(Patching)**라고 합니다.

<hr/>

✅ 장점
성능 최적화
→ 불필요한 DOM 조작을 줄여 브라우저 렌더링 성능 향상
선언형 UI 개발
→ setState()만 호출하면 변경이 자동으로 반영됨
React의 핵심 동작 원리
→ 가상 DOM 덕분에 useState, useEffect 같은 React 기능들이 효율적으로 작동

❌ 단점
메모리 사용 증가
→ 가상 DOM을 위한 추가적인 메모리 사용
Diffing 알고리즘 비용
→ 비교 연산 자체도 비용이 발생 (하지만 React는 Key를 활용해 최적화 가능)

🔑 핵심 키워드

Virtual DOM (가상 DOM)
Diffing Algorithm (비교 알고리즘)
Reconciliation (조정)
State 변화 → 새로운 Virtual DOM 생성
Patch (변경된 부분만 업데이트)
최소한의 DOM 조작으로 성능 최적화
React의 가상 DOM은 실제 DOM 조작을 최소화하고 UI 업데이트를 최적화하는 핵심 개념이에요.
덕분에 React가 빠르고 효율적으로 동작할 수 있죠!

<hr/>

나의 질문

내가 봤을땐 vdom은 단점은 성능이 안좋아진다는? 느낌인데 그럼에도 쓰는이유는 편하기 때문이야?

가상 DOM(Virtual DOM)이 성능이 나빠지는 것처럼 보일 수도 있지만, 실제로는 더 나은 성능을 제공합니다.

❌ 가상 DOM이 성능이 나빠지는 것처럼 보이는 이유

가상 DOM은 실제 DOM보다 한 단계 더 거치는 과정이 있으니까 "추가적인 연산이 필요해서 오히려 느려지는 거 아닌가?" 라는 의문이 들 수 있어요.

새로운 Virtual DOM을 만들고,
기존 Virtual DOM과 비교(Diffing)하고,
변경된 부분만 실제 DOM에 반영해야 하니까요.
이 과정을 보면 비효율적인 것처럼 보일 수도 있죠.

✅ 그럼에도 불구하고 가상 DOM이 성능을 개선하는 이유

가상 DOM이 없을 때는 상태가 변경될 때마다 실제 DOM을 직접 조작해야 합니다. 하지만 실제 DOM 조작은 매우 비용이 크고 느려요.

1️⃣ 직접 DOM 조작이 느린 이유
DOM 업데이트마다 렌더 트리(Render Tree) 재구성
→ 노드가 변경될 때마다 브라우저는 레이아웃을 다시 계산하고, 화면을 다시 그림(리페인트, 리플로우)
불필요한 DOM 조작 발생
→ 변경 사항을 효율적으로 적용하지 않으면 한 번에 여러 번 화면이 다시 그려짐

2️⃣ 가상 DOM을 사용하면 최적화가 가능하다!
React는 가상 DOM을 사용해서 최소한의 DOM 업데이트만 수행하도록 최적화해요.

Batching(일괄 처리)
여러 개의 업데이트를 한 번에 처리해서 불필요한 DOM 조작을 방지
예: setState()를 여러 번 호출해도 한 번만 업데이트

Diffing 알고리즘을 통한 최소 변경
가상 DOM끼리 비교하여 정말 변경된 부분만 업데이트
예: 리스트에서 한 항목만 바뀌었으면, 그 부분만 업데이트

컴포넌트 단위의 렌더링 최적화
shouldComponentUpdate, React.memo, useMemo 등을 사용하면 불필요한 렌더링 방지
💡 결론: 가상 DOM이 불필요한 연산을 추가하는 건 사실이지만, 전체적인 성능은 더 좋아진다!

✅ 불필요한 DOM 업데이트를 줄여서 브라우저 성능 최적화
✅ 개발자는 직접 DOM을 다룰 필요 없이 setState()로 편하게 개발 가능
✅ 컴포넌트 단위로 관리하기 쉬워지고 유지보수성이 증가

따라서 가상 DOM은 개발 편의성과 성능 최적화, 유지보수성을 모두 고려한 해결책이에요.

<hr/>

나의 질문

DOM 업데이트마다 렌더 트리(Render Tree) 재구성
→ 노드가 변경될 때마다 브라우저는 레이아웃을 다시 계산하고, 화면을 다시 그림(리페인트, 리플로우)
이 맥락에서, 리플로우를 적게 일으키기 위해 리플로우 요소를 일으키는 것들을 지양하고 최대한 리페인트만 할 수 있게 개발하여도, vdom이 없다면, 즉 변경된 부분만 바뀌는 로직이 없다면 결국 모든 레이아웃을 다시 계산하기 때문에 필요가 없는거지?

->
리플로우(Reflow)를 줄이기 위해 리플로우를 일으키는 요소들을 피하더라도, 결국 변경된 부분만 업데이트하는 최적화 로직이 없다면 모든 레이아웃을 다시 계산해야 하기 때문에 성능 최적화 효과가 크지 않습니다.

리플로우와 리페인트를 최적화하는 것만으로 충분할까?

리플로우를 줄이기 위해 position: absolute; 같은 기법을 활용하거나, 스타일 변경을 최소화하는 등의 방법은 분명히 중요해요. 하지만 이런 최적화를 하더라도 변경된 부분을 효율적으로 감지하는 로직이 없다면, 모든 요소를 다시 계산해야 하는 문제가 남아 있습니다.

즉, 리플로우를 피하는 전략과 변경된 부분만 업데이트하는 전략은 별개로 필요해요.

🔍 리플로우 최소화 + 변경 감지를 함께 해야 하는 이유

❌ 1. 변경된 부분만 렌더링하지 않으면?
만약 Virtual DOM 같은 변경 감지 로직이 없다면,
document.body.innerHTML = "새로운 내용"처럼 모든 내용을 바꾸는 방식이 되어 버려요.
→ 결국 불필요한 리플로우 & 리페인트가 발생

✅ 2. 가상 DOM이 있으면?
가상 DOM을 사용하면 변경된 부분만 찾아서 업데이트하기 때문에,
리플로우와 리페인트를 최소화할 수 있어요.
→ 브라우저의 리소스 소모를 최소화하면서도 최적의 UI 업데이트 가능

<hr/>

✅ 리플로우를 줄이는 최적화(예: will-change, contain, 애니메이션 최적화)
✅ 변경된 부분만 업데이트하는 최적화(Virtual DOM, Key 사용, Memoization 등)

이 두 가지를 함께 적용해야 진짜로 빠른 UI 렌더링이 가능해요! 🎯🔥
React가 가상 DOM을 사용하는 이유도 결국 **"필요한 부분만 업데이트하는 로직을 추가해서 불필요한 렌더링을 막기 위해서"**입니다.
